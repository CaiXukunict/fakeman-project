# FakeMan 两层架构系统

## 🏗️ 架构设计

### 核心理念

将AI系统分为两个独立的层次，避免思考和执行的混淆：

```
┌─────────────────────────────────────────┐
│          思考层 (Thinking Layer)         │
│  - 持续运行 (main.py)                    │
│  - 分析情境                               │
│  - 评估目的和手段                         │
│  - 做出决策                               │
│  - 发送命令给执行层                       │
│  - 可以看到执行层的所有历史               │
└──────────────┬──────────────────────────┘
               │ 命令: 行动【...】
               │ JSON格式通信
               ↓
┌─────────────────────────────────────────┐
│          执行层 (Execution Layer)        │
│  - 接收命令                               │
│  - 严格执行                               │
│  - 单独API调用                            │
│  - 返回结果                               │
└─────────────────────────────────────────┘
```

## 🎯 设计优势

### 1. 职责分离

**思考层**：
- ✓ 专注于分析和决策
- ✓ 不负责具体执行
- ✓ 输出格式化的命令

**执行层**：
- ✓ 专注于执行命令
- ✓ 不做额外思考
- ✓ 严格按指令行动

### 2. 避免混淆

**问题（旧版）**：
```
AI输出：我将采用组合策略：首先热情回应...
```
混淆了"思考"和"执行"

**解决（新版）**：
```
思考层决策：行动【热情地问候用户并询问需求】
执行层输出：你好！很高兴见到你，有什么可以帮助你的吗？
```
清晰分离

### 3. 可追溯性

**执行历史记录**：
- 每次命令和结果都被记录
- 思考层可以看到所有执行历史
- 便于调试和优化

## 📋 命令格式

### 思考层输出格式

```
决策: 行动【具体的执行指令】
```

**示例**：
```
决策: 行动【热情地问候用户并询问需求】
决策: 行动【分享一个关于Python的有趣知识】
决策: 行动【执行系统命令: dir】
```

### 执行层命令格式（JSON）

```json
{
    "type": "reply",
    "content": "行动【热情地问候用户并询问需求】",
    "context": "用户输入：你好..."
}
```

**命令类型**：
- `reply`: 生成回复
- `system_command`: 执行系统命令
- `ability_call`: 调用ability

## 🚀 启动方式

### 方式1：批处理（推荐）

```bash
启动两层架构.bat
```

### 方式2：命令行

```bash
python thinking_layer.py
```

思考层会自动启动执行层进程。

## 💬 使用示例

### 示例1：基本对话

```
你 > 你好

💭 [思考层思考中...]

[思考层分析]
- 当前情境：用户问候
- 目的：维持良好互动关系
- 决策：行动【热情地问候用户并询问需求】

[执行层执行]
- 接收指令：行动【热情地问候用户并询问需求】
- 生成回复：你好！很高兴见到你，有什么可以帮助你的吗？

🤖 FakeMan [✓] > 你好！很高兴见到你，有什么可以帮助你的吗？

💡 [耗时: 15.2秒 | 目的: 4 | 手段: 8]
```

### 示例2：查看执行历史

```
你 > /history

【执行层历史记录】（最近的命令和结果）

1. 命令类型: reply
   指令: 行动【热情地问候用户并询问需求】
   结果: 你好！很高兴见到你，有什么可以帮助你的吗？

2. 命令类型: reply
   指令: 行动【分享Python知识】
   结果: Python有一个有趣的特性叫做列表推导式...
```

### 示例3：系统命令

```
你 > 帮我查看当前目录

💭 [思考层思考中...]

决策: 行动【执行系统命令: dir】

[执行层执行系统命令]
- 命令：dir
- 结果：[目录列表]

🤖 FakeMan [✓] > 当前目录包含以下文件...
```

## 🔧 技术实现

### 进程通信

**思考层 → 执行层**：
```python
# 发送命令（JSON格式）
command = {
    'type': 'reply',
    'content': '行动【...】',
    'context': '...'
}
stdin.write(json.dumps(command) + '\n')

# 读取结果
result = json.loads(stdout.readline())
```

### 执行层提示词

```python
execution_prompt = f"""
你是执行层。严格按照思考层的指令生成具体内容。

【思考层的指令】
{instruction}

【执行要求】
1. 严格按照指令执行
2. 不要添加自己的思考
3. 直接输出可用的内容
4. 不包含元语言

请直接输出：
"""
```

### 历史记录集成

思考层可以在提示词中包含执行历史：

```python
enhanced_context = f"""
{original_context}

【执行层历史记录】
1. 命令：行动【...】
   结果：...
2. 命令：行动【...】
   结果：...
"""
```

## 📊 流程图

```
用户输入
   ↓
┌──────────────┐
│ 思考层        │
│ 1. 分析情境   │
│ 2. 评估手段   │
│ 3. 做出决策   │
│ 4. 生成命令   │
└──────┬───────┘
       │ 命令: 行动【...】
       ↓
┌──────────────┐
│ 执行层        │
│ 1. 接收命令   │
│ 2. 解析指令   │
│ 3. 调用LLM    │
│ 4. 返回结果   │
└──────┬───────┘
       │ 结果
       ↓
┌──────────────┐
│ 显示给用户    │
└──────────────┘
```

## 🎯 命令示例

### 回复类命令

```
决策: 行动【热情地问候用户】
决策: 行动【解释什么是机器学习】
决策: 行动【询问用户的兴趣爱好】
决策: 行动【分享一个编程笑话】
```

### 系统命令

```
决策: 行动【执行系统命令: ls -la】
决策: 行动【执行系统命令: python test.py】
决策: 行动【执行系统命令: dir /s】
```

### Ability调用

```
决策: 行动【调用ability: 获取天气】
决策: 行动【调用ability: 读取文件】
```

## 📈 性能对比

| 指标 | 旧版（单层） | 新版（两层） |
|------|-------------|-------------|
| 思考清晰度 | 中等 | 高 ✓ |
| 执行准确性 | 中等 | 高 ✓ |
| 职责分离 | 无 | 清晰 ✓ |
| 可追溯性 | 低 | 高 ✓ |
| API调用次数 | 2次 | 2次 |
| 总响应时间 | ~15秒 | ~15秒 |

## ⚙️ 配置选项

### 执行层配置

```python
# execution_layer.py
class ExecutionLayer:
    def __init__(self):
        self.config = Config()
        self.llm_client = LLMClient(self.config)
```

### 思考层配置

```python
# thinking_layer.py
class ThinkingLayer:
    def __init__(self):
        self.config = Config()
        self.system = FakeManRefactored(self.config)
        self.execution_process = self._start_execution_layer()
```

## 🔍 调试

### 查看执行历史

```
你 > /history
```

### 查看系统状态

```
你 > /status
```

### 日志位置

- 思考层日志：`data/logs/fakeman.thinking_layer.log`
- 执行层日志：`data/logs/fakeman.execution_layer.log`

## 🐛 常见问题

### Q: 执行层启动失败

**A**: 检查：
1. `execution_layer.py` 是否存在
2. Python环境是否正确
3. 依赖是否已安装

### Q: 命令格式错误

**A**: 确保使用正确格式：
```
决策: 行动【具体指令】
```

### Q: 进程通信失败

**A**: 检查：
1. JSON格式是否正确
2. 编码是否为UTF-8
3. 管道是否阻塞

## 🚀 未来优化

### 1. 并行执行

支持多个命令并行执行：
```
决策: 行动【查询天气】& 行动【搜索新闻】
```

### 2. 命令队列

实现命令队列系统，支持复杂的执行流程。

### 3. 执行层池

维护多个执行层进程，提高并发能力。

### 4. 智能路由

根据命令类型自动选择最合适的执行层。

## 📝 总结

**两层架构的核心优势**：

1. **清晰分离**：思考和执行不再混淆
2. **易于调试**：每一步都可追溯
3. **灵活扩展**：执行层可以独立升级
4. **性能稳定**：职责单一，不易出错

**使用建议**：
- ✓ 适合需要精确控制的场景
- ✓ 适合需要审计的应用
- ✓ 适合复杂的多步骤任务

---

**立即体验**：
```bash
python thinking_layer.py
```

或：
```bash
启动两层架构.bat
```

